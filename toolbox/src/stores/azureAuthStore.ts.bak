import { create } from 'zustand';
import { azureAdAuth } from '@/lib/azureAdClient';

export interface AzureAuthUser {
  id: string;
  email: string;
  name: string;
  tenantId: string;
  isEmployee: boolean;
}

interface AzureAuthState {
  user: AzureAuthUser | null;
  accessToken: string | null;
  loading: boolean;
  error: string | null;
  isAuthenticated: boolean;
  
  // Actions
  setUser: (user: AzureAuthUser | null) => void;
  setAccessToken: (token: string | null) => void;
  setLoading: (loading: boolean) => void;
  setError: (error: string | null) => void;
  login: () => Promise<boolean>;
  logout: () => Promise<void>;
  refreshToken: () => Promise<string | null>;
  initialize: () => Promise<void>;
  reset: () => void;
}

// Use relative URLs in development to leverage Vite proxy, absolute URLs in production
const getApiUrl = (endpoint: string) => {
  if (import.meta.env.DEV) {
    // In development, always prepend /api for Vite proxy
    return `/api${endpoint}`;
  } else {
    const API_BASE_URL = import.meta.env.VITE_API_URL || 'https://tangram-marketing-functions.azurewebsites.net/api';
    return `${API_BASE_URL}${endpoint}`;
  }
};

export const useAzureAuthStore = create<AzureAuthState>((set, get) => ({
  user: null,
  accessToken: null,
  loading: true,
  error: null,
  isAuthenticated: false,

  setUser: (user) => set({ user, isAuthenticated: !!user }),
  setAccessToken: (token) => set({ accessToken: token }),
  setLoading: (loading) => set({ loading }),
  setError: (error) => set({ error }),

  login: async () => {
    set({ loading: true, error: null });
    
    try {
      const result = await azureAdAuth.loginPopup();
      const accessToken = result.accessToken;
      const userInfo = azureAdAuth.getUserInfo();
      
      if (userInfo) {
        set({
          user: userInfo,
          accessToken: accessToken,
          isAuthenticated: true,
          loading: false,
          error: null
        });
        
        // Verify the user with the API
        await get().verifyUserWithApi();
        return true;
      } else {
        throw new Error('Failed to get user information');
      }
    } catch (error: any) {
      console.error('Azure AD login failed:', error);
      set({
        error: error.message || 'Login failed',
        loading: false,
        isAuthenticated: false
      });
      return false;
    }
  },

  logout: async () => {
    set({ loading: true });
    
    try {
      await azureAdAuth.logout();
      set({
        user: null,
        accessToken: null,
        isAuthenticated: false,
        loading: false,
        error: null
      });
    } catch (error: any) {
      console.error('Azure AD logout failed:', error);
      set({ error: error.message || 'Logout failed', loading: false });
    }
  },

  refreshToken: async () => {
    try {
      const token = await azureAdAuth.getAccessToken(true);
      set({ accessToken: token });
      return token;
    } catch (error: any) {
      console.error('Token refresh failed:', error);
      set({ error: error.message || 'Token refresh failed' });
      return null;
    }
  },

  initialize: async () => {
    set({ loading: true });
    
    try {
      await azureAdAuth.initialize();
      
      // Check if user is already logged in
      if (azureAdAuth.isLoggedIn()) {
        const userInfo = azureAdAuth.getUserInfo();
        const accessToken = await azureAdAuth.getAccessToken();
        
        if (userInfo && accessToken) {
          set({
            user: userInfo,
            accessToken: accessToken,
            isAuthenticated: true,
            loading: false
          });
          
          // Verify the user with the API
          await get().verifyUserWithApi();
        } else {
          set({ loading: false });
        }
      } else {
        set({ loading: false });
      }
    } catch (error: any) {
      console.error('Azure AD initialization failed:', error);
      set({
        error: error.message || 'Initialization failed',
        loading: false
      });
    }
  },

  // Verify user with API (similar to refreshUser in original authStore)
  verifyUserWithApi: async () => {
    const { accessToken } = get();
    
    try {
      const response = await fetch(getApiUrl('/health'), {
        headers: {
          'Authorization': `Bearer ${accessToken}`,
          'Content-Type': 'application/json'
        }
      });

      if (response.ok) {
        const data = await response.json();
        console.log('✅ API verification successful:', data);
        
        // If API returns updated user info, use it
        if (data.authentication?.user) {
          const currentUser = get().user;
          if (currentUser) {
            set({
              user: {
                ...currentUser,
                name: data.authentication.user,
                email: data.authentication.email || currentUser.email
              }
            });
          }
        }
      } else if (response.status === 401) {
        console.log('🔄 Token expired, attempting refresh...');
        const newToken = await get().refreshToken();
        
        if (!newToken) {
          console.log('❌ Token refresh failed, logging out');
          await get().logout();
        }
      } else {
        console.warn('API verification failed:', response.status);
      }
    } catch (error) {
      console.error('API verification error:', error);
      // Don't fail the whole auth process if API verification fails
    }
  },

  reset: () => {
    set({
      user: null,
      accessToken: null,
      isAuthenticated: false,
      loading: false,
      error: null
    });
  }
}));

// Initialize on store creation
if (typeof window !== 'undefined') {
  useAzureAuthStore.getState().initialize();
} 